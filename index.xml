<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>XiaBing Blog</title><link>https://xiabing992.github.io/</link><description>Recent content on XiaBing Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 11 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://xiabing992.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>TCP IP网络编程</title><link>https://xiabing992.github.io/blog/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Sat, 11 Nov 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>套接字类型和协议设置 协议族 计算机的通信规则 套接字类型 套接字的传输方式 面向连接的套接字（SOCK_STREAM） 可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字
按序传输数据 不存在数据边界 套接字连接必须一一对应 面向消息的套接字（SOCK_DGRAM） 不可靠的、不按序传输的、以数据的高速传输为目的的套接字
强调快速传输 有数据边界 协议的最终选择 socket函数指明协议族、套接字类型就可以了，第三个参数一般为0 除非同一协议族中存在多个数据传输方式相同的协议 地址族与数据序列 网络地址分类与主机地址边界 A类地址的首字节范围：0-127（0开始） B类地址的首字节范围：128-191（10开始） C类地址的首字节范围：192-223（110开始） 地址信息的表示 表示IPv4地址的结构体 struct sockaddr_in { sa_family_t sin_family; //protocl uint16_t sin_port; //port struct in_addr sin_addr; //ip char sin_zero[8]; //不使用 } struct in_addr { In_addr_t s_addr; } sockaddr_in sin_family sin_port：16位端口号 sin_addr：32位IP sin_zero：为使sockaddr_in大小与sockaddr结构体大小保持一致 网络字节序与地址变换 在通过网络传输数据时统一字节序为网络字节序-即大端序
字节序转换 理论上系统是大端序，就不需要转换成网络字节序了；但是为了代码可移植性，还是要写
传输的数据（buffer[]）会自动转换
网络地址的初始化与分配 将字符串信息转换为网络字节序的整数型 传递点分十进制，返回32位整数型数据 in_addr_t inet_addr(const char* string); int inet_aton(const char* string, struct in_addr* addr); //使用频率更高，结果自动写入结构体 将ip转成字符串 这里要注意，返回的是char*，要及时复制出去；因为内部申请了内存，下一次调用时之前结果会被覆盖 char* inet_ntoa(struct in_addr adr); INADDR_ANY 使用INADDR_ANY可以自动获取服务器端的ip地址（只有一个NIC时，直接使用；有多个NIC时，会监听本机所有IP） Windows的转换函数 Winsock2中增加了两个字符串转换函数：WSAStringToAddress和WSAAddressToString 功能与inet_ntoa和inet_addr相同 优点：支持多种协议，在IPV4和IPV6中都使用 缺点：依赖于Windows平台 基于TCP的服务器端/客户端 TCP原理 TCP不会出现传输的数据大于服务端缓冲区的情况，因为有TCP中有滑动窗口协议 TCP内部工作原理 三次握手 与对方主机的数据交换 ACK号 = SEQ号 + 传递的字节数 + 1 最后加1是为了高速对方下次要传递的SEQ号 四次分手 基于UDP的服务端/客户端 TCP和UDP的差异主要在流控制 实现基于UDP的服务端/客户端 UDP中只有创建套接字和数据交换过程 每次传输时都要添加目标地址信息 ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen); 由于UDP数据的发送端不固定，因此每次接收数据的时候都可以获取发送端的信息 UDP客户端套接字的地址分配 bind函数不区分UDP和TCP，可以使用，但是一般在客户端不使用 如果调用sendto函数时未分配地址信息，则在首次调用sendto函数时给相应套接字自动分配IP和端口，并且此时分配的地址一直保留到程序结束为止 UDP的数据传输特性和调用connect函数 存在数据边界的UDP套接字 UDP是具有数据边界的协议,传输中调用I/O函数的次数非常重要 已连接UDP套接字与未连接UDP套接字 通过sendto函数传输数据的过程大致分为以下3个阶段:</description></item><item><title>Linux内核设计与实现</title><link>https://xiabing992.github.io/blog/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>Linux内核简介 Unix强大的根本原因：
简洁：仅仅提供几百个系统调用 一切皆文件 Unix的内核和相关系统工具软件是用C语言写的 Unix进程创建非常迅速 提供了一套非常简单但又稳定的进程间通信元语 在系统中运行的应用程序通过系统调用来与内核通信：应用程序通常调用库函数，再由库函数通过系统调用让内核完成各种不同任务 单内核与微内核设计之比较 单内核（宏内核）就是整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上，所以这样的内核通常以单个静态二进制文件的形式放于磁盘中，所有的内核服务都在这样一个大内核地址空间上运行
简单、性能高：内核之间的通信是微不足道的，因为大家都运行在内核态 微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。所有的服务器都保持独立并运行在各自的地址空间上。并且只提供一些必要的服务
因此不可能像单模块那样直接调用函数，而是使用IPC（进程间通信）机制互通消息 进程管理 进程描述符及任务结构 内核把进程的列表存放在叫做任务队列的双向链表中 链表中的每一项都是类型为task_struct，称为进程描述符的结构 进程描述符包含一个具体进程的所有信息：它打开的文件、进程的地址空间、挂起的信号、进程的状态等 slab机制 用于针对一些小块内存及经常分配和释放的对象，如进程描述符 分配进程描述符 Linux通过slab分配器分配task_struct结构 进程描述符的存放 内核使用PID来标识每个进程 进程状态 进程描述符中的state域描述了进程的当前状态，系统中的进程必将处于五种进程状态中一种： TASK_RUNNING(运行)：进程可执行、正在执行、或者在运行队列中等待执行；这是进程在用户空间中执行的唯一可能的状态，也可以应用到内核空间中正在执行的进程 TASK_INTERRUPTIBLE(可中断)：进程正在睡眠（被阻塞），等待条件的达成；一旦条件达成，内核就会把它设置成运行 TASK_UNINTERRUPTRIBLE(不可中断)：除了就算接收信号也不会被唤醒，这个状态与可中断相同 __TASK_TRACED：被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪 ————TASK_STOPPED(停止)：进程停止执行，进程没有投入运行也不能投入运行。通常这种状态发生在收到SIGSTOP、SIGTSTP等信号的时候 设置当前进程状态 内核经常需要调整某个进程的状态，使用set_task_state(task, state)函数： set_task_state(task, state); //将任务task的状态设置为state 进程上下文 一般程序在用户空间执行，一旦执行了某个系统调用或者触发了某个异常，就陷入了内核空间。此时称内核“代表进程执行”并处于进程上下文中 除非在此间隙有更高优先级的进程需要执行，否则在内核击退出的时候，程序恢复在用户空间继续执行 进程家族树 所有进程都是PID为1的init进程的后代 内核在系统启动的最后阶段启动init进程，该进程读取系统的初始化脚本并执行其他的相关程序，最终完成整个系统启动的整个过程 进程间的关系放在进程描述符中，每个task_struct都包含一个指向其父进程task_struct，叫做parent的指针，还包含一个称为children的子进程链表 进程创建 UNIX将创建进程分解到两个单独的函数中执行：fork() 和 exec(); fork通过拷贝当前进程创建一个子进程 exec函数负责读取可执行文件并将其载入地址空间开始运行 写时拷贝 COW：将复制操作推迟到第一次写的时候进行。内核会保留每个页面的引用计数，每次复制某个页面时，引用计数减一，当页面只有一个引用时，跳过复制，直接修改
传统的fork()系统调用直接把所有的资源给新创建的进程，这种实现过于简单 并且效率低下
Linux的fork()使用写时拷贝页实现。写时拷贝时一种可以推迟甚至免除拷贝数据的技术；内核此时并不复制整个进程空间，而是让父进程和子进程共享同一个拷贝
只有在需要写入时，数据才会复制，从而使各种进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享
在页根本不会被写入的情况下，就无需复制了
fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符
在一般情况下，进程创建后会马上运行一个可执行文件的程序，这种优化可以避免拷贝大量根本就不会被使用的数据 总结：fork之后，kernel会把父进程的内存页都设置成read-only，然后将子进程页指向父进程页。当父子进程都只读内存时，相安无事。当其中某个进程开始写内存时，CPU硬件检测到内存页时read-only的，触发页异常中断，陷入kernel的中断例程。中断例程中，kernel就会把触发异常的页复制一份，于是父子进程各自持有独有的一份。
COW优缺点：
可减少分配和复制带来的瞬时延迟 减少不必要资源的复制。比如fork时，父进程的代码段和只读数据段都不允许修改，所以无需修改 如果在fork之后，父子进程都产生了大量的写操作，会产生大量的页错误 fork() Linux通过clone()系统调用实现fork() fork()、vfork()、__clone()库函数都根据自己需要的参数调用clone()，然后由clone()调用do_fork() vfork() 除了不拷贝父进程的页表外，vfork()和fork()功能相同(fork支持COW后，已经一样了) 子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行exec() fork和vfork区别：</description></item><item><title>深入理解Linux网络</title><link>https://xiabing992.github.io/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C/</guid><description>深入理解Linux网络</description></item><item><title>汇编语言</title><link>https://xiabing992.github.io/blog/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</guid><description>基础知识 连接CPU和其他芯片的导线，称为总线（地址总线、控制总线、数据总线） 每一种CPU都有自己的汇编指令集 接口卡：CPU对外部设备不能直接控制，通过扩展插槽将其通过总线和CPU相连 BIOS：是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出（例如，主板上的ROM存储着主板的BIOS，显卡上存储的是显卡的BIOS） 汇编语言由3类指令组成：
汇编指令：有相应的机器码 伪指令：没有相应机器码，由编译器执行，计算机不执行 其他符号：由编译器识别，没有相应机器码 寄存器</description></item><item><title>程序员的自我修养</title><link>https://xiabing992.github.io/blog/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</guid><description>简介 线程 线程可以访问进程内存里的所有数据，但也拥有自己的私有存储空间
当线程数小于等于处理器数量时，线程的并发是真正的并发
Linux的多线程 Windows对进程和线程实现如教科书一样标准，其内核有明确的线程和进程概念 对于Linux，线程并不是一个通用的概念。Linux内核中并不存在真正意义的线程概念，其将所有的执行实体称为任务（Task），每一个任务都类似于一个单线程的进程，但是不同的任务之间可以选择共享内存空间，共享同一个内存空间的多个任务构成了一个进程。 用户线程不一定一等一对应同等数量的内核线程 静态链接 编译过程 预编译：主要处理源代码中的预编译命令，删除注释（生成.i或者.ii文件）。 编译：把预处理完的文件进行词法分析、语法分析等并生成相应的汇编代码文件（生成.s文件）。 扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化等 汇编：将汇编代码转成机器可以执行的指令（生成.o文件）。 链接：ld命令（生成.out文件）。 地址和空间分配、符号决议、重定位等 目标文件 目标文件就是没有链接的文件。（Windows下为.obj, Linux下为.o） Windows下他们为PE-COFF文件格式，Linux下为ELF文件格式 局部变量存放在进程的堆栈中，而不存放在目标文件中 ELF文件类型：可重定位文件、可执行文件、共享目标文件、核心转储文件
动态链接库与静态链接库 动态链接库：Windows下为.dll，Linux下为.so 静态链接库：Windows下为.lib，Linux下为.a 目标文件的样子 代码段：程序源代码编译后放在代码段（.code .text） 数据段：已初始化的全局变量和局部静态数据放在数据段（.data） .bss段：未初始化的全局变量和局部静态数据放在.bss段，.bss段只是未两者预留位置而已，并没有内容，所以它在文件中不占据空间 只读数据段（.rodata）：一般是程序里的只读变量（const） 注释信息段（.comment）：保存编译器和系统版本信息 堆栈提示段（.note.GNU-stack） 等等 c++的函数重载利用了符号修饰。
弱符号和强符号 编译器默认函数和初始化了的全局变量未强符号，未初始化的全局变量为弱符号 静态链接 ELF文件定义了两种特殊段：
.init 构成了进程的初始化代码，在main函数调用之前执行 .fini main函数正常退出时，执行 API与ABI：
API指应用程序接口，ABI指二进制层面接口 API相同不代表ABI相同 可执行文件的装载与进程 程序的虚拟地址空间的大小由计算机的硬件平台决定 指针大小的位数与虚拟空间的位数相同 动态装载方法 覆盖装入（Overlay）:程序员需要手工将模块按照他们之间的调用依赖关系组织成树状结构 页映射（Paging） 动态链接 进程A和B同时使用同一个动态库，这个动态库被加载时数据段会有自己独立的副本 动态链接器本身是静态链接的 GOT表和PLT表 GOT：ELF文件中用于定位全局变量和函数的表 PLT：ELF文件中用于延迟绑定的表 动态链接比静态链接慢的原因 对于全局和静态数据访问需要复杂的GOT定位，让后间接寻址；对于模块间的调用也要先GOT定位，再跳转 程序开始执行时，动态连接器都要进行一次链接 延迟绑定：对于很少用到的模块，再函数第一次使用到时才进行绑定
动态链接的步骤 动态链接器自举 装载共享对象 重定位和初始化 Linux共享库的组织 动态链接器会在/lib、/usr/lib、 /etc/ld.so.conf配置文件指定的目录中查找共享库 共享库文件名 libname.</description></item><item><title>程序员的自我修养-静态链接与动态链接</title><link>https://xiabing992.github.io/blog/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</guid><description>程序员的自我修养中比较重要的几章</description></item><item><title>Effective C++</title><link>https://xiabing992.github.io/blog/effective-c++/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/effective-c++/</guid><description>Effective C++ 导言 除非有好的理由允许隐式转换，否则声明explicit 拷贝构造函数和拷贝赋值操作符：如果有新对象被定义，一定会有个构造函数被调用 class Widget { public: Widget(); Widget(const Widget&amp;amp;rhs); Widget&amp;amp; operator=(const Widget&amp;amp; rhs); }; Widget w1; //调用构造函数 Widget w2(w1); //调用拷贝构造函数 w1 = w2; //调用 = Widget w3 = w2; //调用拷贝构造函数 让自己习惯C++ 视C++为一个语言联邦 C++ = &amp;lsquo;c&amp;rsquo; + &amp;lsquo;Object-Oriented c++&amp;rsquo; + &amp;lsquo;Template c++&amp;rsquo; + &amp;lsquo;STL&amp;rsquo; 在 C 中，pass-by-value通常比pass-by-reference高效，而在C++中由于构造函数和析构函数的存在，pass-by-reference-to-const往往更好（和编译器层面有关，存在空指针，但没有空引用） 尽量以const, enum, inline 替换#define 获得编译错误时，#define定义的方式会带来困惑 对于单纯常量，最好以const对象或enums替换#define 对于形似函数的宏，最好使用inline函数替换#define 尽可能使用const bitwise constess: const成员函数不能更改non-static成员变量
class Rational { ... }; const Rational operator* (const Rational&amp;amp; lhs,const Rational&amp;amp; rhs) { .</description></item><item><title/><link>https://xiabing992.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/about/</guid><description>UESTC</description></item><item><title>书籍清单</title><link>https://xiabing992.github.io/blog/%E4%B9%A6%E7%B1%8D%E6%B8%85%E5%8D%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E4%B9%A6%E7%B1%8D%E6%B8%85%E5%8D%95/</guid><description>ing</description></item></channel></rss>