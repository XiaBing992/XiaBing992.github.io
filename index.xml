<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>XiaBing Blog</title><link>https://xiabing992.github.io/</link><description>Recent content on XiaBing Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 24 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://xiabing992.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog Post with Inline Images</title><link>https://xiabing992.github.io/blog/post1/</link><pubDate>Fri, 24 Nov 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/post1/</guid><description>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</description></item><item><title>Blog Post With Extra Extra Long Title That Keeps On Going</title><link>https://xiabing992.github.io/blog/post2/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/post2/</guid><description>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</description></item><item><title>Blog Post 3</title><link>https://xiabing992.github.io/blog/post3/</link><pubDate>Wed, 22 Nov 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/post3/</guid><description>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</description></item><item><title>Blog Post 4</title><link>https://xiabing992.github.io/blog/post4/</link><pubDate>Tue, 21 Nov 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/post4/</guid><description>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec id erat enim. Ut cursus magna sed luctus auctor. Sed eu augue dignissim, lobortis ipsum eu, dictum nisi. Integer varius ex maximus quam lobortis accumsan. Morbi mollis vulputate metus, aliquam feugiat arcu porta a. Quisque id justo ultricies, lacinia elit quis, pulvinar odio. Fusce feugiat at velit vitae lobortis. Nulla fringilla metus et sem mattis posuere. Nulla pellentesque quam sit amet est posuere, tincidunt auctor ligula bibendum. Donec dapibus lacinia nibh, convallis ultrices enim laoreet et.</description></item><item><title>Effective c++</title><link>https://xiabing992.github.io/blog/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Sat, 11 Nov 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>套接字类型和协议设置 协议族 计算机的通信规则 套接字类型 套接字的传输方式 面向连接的套接字（SOCK_STREAM） 可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字
按序传输数据 不存在数据边界 套接字连接必须一一对应 面向消息的套接字（SOCK_DGRAM） 不可靠的、不按序传输的、以数据的高速传输为目的的套接字
强调快速传输 有数据边界 协议的最终选择 socket函数指明协议族、套接字类型就可以了，第三个参数一般为0 除非同一协议族中存在多个数据传输方式相同的协议 地址族与数据序列 网络地址分类与主机地址边界 A类地址的首字节范围：0-127（0开始） B类地址的首字节范围：128-191（10开始） C类地址的首字节范围：192-223（110开始） 地址信息的表示 表示IPv4地址的结构体 struct sockaddr_in { sa_family_t sin_family; //protocl uint16_t sin_port; //port struct in_addr sin_addr; //ip char sin_zero[8]; //不使用 } struct in_addr { In_addr_t s_addr; } sockaddr_in sin_family sin_port：16位端口号 sin_addr：32位IP sin_zero：为使sockaddr_in大小与sockaddr结构体大小保持一致 网络字节序与地址变换 在通过网络传输数据时统一字节序为网络字节序-即大端序
字节序转换 理论上系统是大端序，就不需要转换成网络字节序了；但是为了代码可移植性，还是要写
传输的数据（buffer[]）会自动转换
网络地址的初始化与分配 将字符串信息转换为网络字节序的整数型 传递点分十进制，返回32位整数型数据 in_addr_t inet_addr(const char* string); int inet_aton(const char* string, struct in_addr* addr); //使用频率更高，结果自动写入结构体 将ip转成字符串 这里要注意，返回的是char*，要及时复制出去；因为内部申请了内存，下一次调用时之前结果会被覆盖 char* inet_ntoa(struct in_addr adr); INADDR_ANY 使用INADDR_ANY可以自动获取服务器端的ip地址（只有一个NIC时，直接使用；有多个NIC时，会监听本机所有IP） Windows的转换函数 Winsock2中增加了两个字符串转换函数：WSAStringToAddress和WSAAddressToString 功能与inet_ntoa和inet_addr相同 优点：支持多种协议，在IPV4和IPV6中都使用 缺点：依赖于Windows平台 基于TCP的服务器端/客户端 TCP原理 TCP不会出现传输的数据大于服务端缓冲区的情况，因为有TCP中有滑动窗口协议 TCP内部工作原理 三次握手 与对方主机的数据交换 ACK号 = SEQ号 + 传递的字节数 + 1 最后加1是为了高速对方下次要传递的SEQ号 四次分手 基于UDP的服务端/客户端 TCP和UDP的差异主要在流控制 实现基于UDP的服务端/客户端 UDP中只有创建套接字和数据交换过程 每次传输时都要添加目标地址信息 ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen); 由于UDP数据的发送端不固定，因此每次接收数据的时候都可以获取发送端的信息 UDP客户端套接字的地址分配 bind函数不区分UDP和TCP，可以使用，但是一般在客户端不使用 如果调用sendto函数时未分配地址信息，则在首次调用sendto函数时给相应套接字自动分配IP和端口，并且此时分配的地址一直保留到程序结束为止 UDP的数据传输特性和调用connect函数 存在数据边界的UDP套接字 UDP是具有数据边界的协议,传输中调用I/O函数的次数非常重要 已连接UDP套接字与未连接UDP套接字 通过sendto函数传输数据的过程大致分为以下3个阶段:</description></item><item><title>Effective c++</title><link>https://xiabing992.github.io/blog/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>Linux内核简介 Unix强大的根本原因：
简洁：仅仅提供几百个系统调用 一切皆文件 Unix的内核和相关系统工具软件是用C语言写的 Unix进程创建非常迅速 提供了一套非常简单但又稳定的进程间通信元语 在系统中运行的应用程序通过系统调用来与内核通信：应用程序通常调用库函数，再由库函数通过系统调用让内核完成各种不同任务 单内核与微内核设计之比较 单内核（宏内核）就是整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上，所以这样的内核通常以单个静态二进制文件的形式放于磁盘中，所有的内核服务都在这样一个大内核地址空间上运行
简单、性能高：内核之间的通信是微不足道的，因为大家都运行在内核态 微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。所有的服务器都保持独立并运行在各自的地址空间上。并且只提供一些必要的服务
因此不可能像单模块那样直接调用函数，而是使用IPC（进程间通信）机制互通消息 进程管理 进程描述符及任务结构 内核把进程的列表存放在叫做任务队列的双向链表中 链表中的每一项都是类型为task_struct，称为进程描述符的结构 进程描述符包含一个具体进程的所有信息：它打开的文件、进程的地址空间、挂起的信号、进程的状态等 slab机制 用于针对一些小块内存及经常分配和释放的对象，如进程描述符 分配进程描述符 Linux通过slab分配器分配task_struct结构 进程描述符的存放 内核使用PID来标识每个进程 进程状态 进程描述符中的state域描述了进程的当前状态，系统中的进程必将处于五种进程状态中一种： TASK_RUNNING(运行)：进程可执行、正在执行、或者在运行队列中等待执行；这是进程在用户空间中执行的唯一可能的状态，也可以应用到内核空间中正在执行的进程 TASK_INTERRUPTIBLE(可中断)：进程正在睡眠（被阻塞），等待条件的达成；一旦条件达成，内核就会把它设置成运行 TASK_UNINTERRUPTRIBLE(不可中断)：除了就算接收信号也不会被唤醒，这个状态与可中断相同 __TASK_TRACED：被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪 ————TASK_STOPPED(停止)：进程停止执行，进程没有投入运行也不能投入运行。通常这种状态发生在收到SIGSTOP、SIGTSTP等信号的时候 设置当前进程状态 内核经常需要调整某个进程的状态，使用set_task_state(task, state)函数： set_task_state(task, state); //将任务task的状态设置为state 进程上下文 一般程序在用户空间执行，一旦执行了某个系统调用或者触发了某个异常，就陷入了内核空间。此时称内核“代表进程执行”并处于进程上下文中 除非在此间隙有更高优先级的进程需要执行，否则在内核击退出的时候，程序恢复在用户空间继续执行 进程家族树 所有进程都是PID为1的init进程的后代 内核在系统启动的最后阶段启动init进程，该进程读取系统的初始化脚本并执行其他的相关程序，最终完成整个系统启动的整个过程 进程间的关系放在进程描述符中，每个task_struct都包含一个指向其父进程task_struct，叫做parent的指针，还包含一个称为children的子进程链表 进程创建 UNIX将创建进程分解到两个单独的函数中执行：fork() 和 exec(); fork通过拷贝当前进程创建一个子进程 exec函数负责读取可执行文件并将其载入地址空间开始运行 写时拷贝 COW：将复制操作推迟到第一次写的时候进行。内核会保留每个页面的引用计数，每次复制某个页面时，引用计数减一，当页面只有一个引用时，跳过复制，直接修改
传统的fork()系统调用直接把所有的资源给新创建的进程，这种实现过于简单 并且效率低下
Linux的fork()使用写时拷贝页实现。写时拷贝时一种可以推迟甚至免除拷贝数据的技术；内核此时并不复制整个进程空间，而是让父进程和子进程共享同一个拷贝
只有在需要写入时，数据才会复制，从而使各种进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享
在页根本不会被写入的情况下，就无需复制了
fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符
在一般情况下，进程创建后会马上运行一个可执行文件的程序，这种优化可以避免拷贝大量根本就不会被使用的数据 总结：fork之后，kernel会把父进程的内存页都设置成read-only，然后将子进程页指向父进程页。当父子进程都只读内存时，相安无事。当其中某个进程开始写内存时，CPU硬件检测到内存页时read-only的，触发页异常中断，陷入kernel的中断例程。中断例程中，kernel就会把触发异常的页复制一份，于是父子进程各自持有独有的一份。
COW优缺点：
可减少分配和复制带来的瞬时延迟 减少不必要资源的复制。比如fork时，父进程的代码段和只读数据段都不允许修改，所以无需修改 如果在fork之后，父子进程都产生了大量的写操作，会产生大量的页错误 fork() Linux通过clone()系统调用实现fork() fork()、vfork()、__clone()库函数都根据自己需要的参数调用clone()，然后由clone()调用do_fork() vfork() 除了不拷贝父进程的页表外，vfork()和fork()功能相同(fork支持COW后，已经一样了) 子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行exec() fork和vfork区别：</description></item><item><title>Effective c++</title><link>https://xiabing992.github.io/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C/</guid><description>内核是如何接受网络包的 ksoftirqd内核线程：用于执行软中断 数据是如何从网卡到协议栈的 内核接受包路径 Linux启动 在接受网卡数据包之前，需要做好准备工作
创建ksoftirqd内核线程
通过执行spawn_ksoftirqd（位于kernel/softirq.c）来创建出softirqd线程 当ksoftirqd被创建出来后，会进入自己的线程循环函数ksoftirqd_should_run和run_ksoftirqd 判断有无软中断需要处理，不仅有网络软中断，还有其他软中断 //file: kernel/softirq.c static struct smp_hotplug_thread softirq_threads = { .store = &amp;amp;ksoftirqd, .thread_should_run = ksoftirqd_should_run, .thread_fn = run_ksoftirqd, .thread_comm = &amp;#34;ksoftirqd/%u&amp;#34;, }; static __init int spawn_ksoftirqd(void) { register_cpu_notifier(&amp;amp;cpu_nfb); //创建线程 BUG_ON(smpboot_register_percpu_thread(&amp;amp;softirq_threads)); return 0; } early_initcall(spawn_ksoftirqd); 2. 网络子系统初始化
为每个CPU初始化softnet_data，也会为PX_SOFTIRQ和TX_SOFTIRQ注册处理函数 Linux内核通过subsys_initcall来初始化各个子系统，这里使用net_dev_init函数进行网络子系统初始化 //file: net/core/dev.c static int __init net_dev_init(void) { ...... for_each_possible_cpu(i) { struct softnet_data *sd = &amp;amp;per_cpu(softnet_data, i); memset(sd, 0, sizeof(*sd)); skb_queue_head_init(&amp;amp;sd-&amp;gt;input_pkt_queue); skb_queue_head_init(&amp;amp;sd-&amp;gt;process_queue); sd-&amp;gt;completion_queue = NULL; INIT_LIST_HEAD(&amp;amp;sd-&amp;gt;poll_list); .</description></item><item><title>Effective c++</title><link>https://xiabing992.github.io/blog/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</guid><description>基础知识 连接CPU和其他芯片的导线，称为总线（地址总线、控制总线、数据总线） 每一种CPU都有自己的汇编指令集 接口卡：CPU对外部设备不能直接控制，通过扩展插槽将其通过总线和CPU相连 BIOS：是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出（例如，主板上的ROM存储着主板的BIOS，显卡上存储的是显卡的BIOS） 汇编语言由3类指令组成：
汇编指令：有相应的机器码 伪指令：没有相应机器码，由编译器执行，计算机不执行 其他符号：由编译器识别，没有相应机器码 寄存器</description></item><item><title>Effective c++</title><link>https://xiabing992.github.io/blog/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</guid><description>简介 线程 线程可以访问进程内存里的所有数据，但也拥有自己的私有存储空间
当线程数小于等于处理器数量时，线程的并发是真正的并发
Linux的多线程 Windows对进程和线程实现如教科书一样标准，其内核有明确的线程和进程概念 对于Linux，线程并不是一个通用的概念。Linux内核中并不存在真正意义的线程概念，其将所有的执行实体称为任务（Task），每一个任务都类似于一个单线程的进程，但是不同的任务之间可以选择共享内存空间，共享同一个内存空间的多个任务构成了一个进程。 用户线程不一定一等一对应同等数量的内核线程 静态链接 编译过程 预编译：主要处理源代码中的预编译命令，删除注释（生成.i或者.ii文件）。 编译：把预处理完的文件进行词法分析、语法分析等并生成相应的汇编代码文件（生成.s文件）。 扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化等 汇编：将汇编代码转成机器可以执行的指令（生成.o文件）。 链接：ld命令（生成.out文件）。 地址和空间分配、符号决议、重定位等 目标文件 目标文件就是没有链接的文件。（Windows下为.obj, Linux下为.o） Windows下他们为PE-COFF文件格式，Linux下为ELF文件格式 局部变量存放在进程的堆栈中，而不存放在目标文件中 ELF文件类型：可重定位文件、可执行文件、共享目标文件、核心转储文件
动态链接库与静态链接库 动态链接库：Windows下为.dll，Linux下为.so 静态链接库：Windows下为.lib，Linux下为.a 目标文件的样子 代码段：程序源代码编译后放在代码段（.code .text） 数据段：已初始化的全局变量和局部静态数据放在数据段（.data） .bss段：未初始化的全局变量和局部静态数据放在.bss段，.bss段只是未两者预留位置而已，并没有内容，所以它在文件中不占据空间 只读数据段（.rodata）：一般是程序里的只读变量（const） 注释信息段（.comment）：保存编译器和系统版本信息 堆栈提示段（.note.GNU-stack） 等等 c++的函数重载利用了符号修饰。
弱符号和强符号 编译器默认函数和初始化了的全局变量未强符号，未初始化的全局变量为弱符号 静态链接 ELF文件定义了两种特殊段：
.init 构成了进程的初始化代码，在main函数调用之前执行 .fini main函数正常退出时，执行 API与ABI：
API指应用程序接口，ABI指二进制层面接口 API相同不代表ABI相同 可执行文件的装载与进程 程序的虚拟地址空间的大小由计算机的硬件平台决定 指针大小的位数与虚拟空间的位数相同 动态装载方法 覆盖装入（Overlay）:程序员需要手工将模块按照他们之间的调用依赖关系组织成树状结构 页映射（Paging） 动态链接 进程A和B同时使用同一个动态库，这个动态库被加载时数据段会有自己独立的副本 动态链接器本身是静态链接的 GOT表和PLT表 GOT：ELF文件中用于定位全局变量和函数的表 PLT：ELF文件中用于延迟绑定的表 动态链接比静态链接慢的原因 对于全局和静态数据访问需要复杂的GOT定位，让后间接寻址；对于模块间的调用也要先GOT定位，再跳转 程序开始执行时，动态连接器都要进行一次链接 延迟绑定：对于很少用到的模块，再函数第一次使用到时才进行绑定
动态链接的步骤 动态链接器自举 装载共享对象 重定位和初始化 Linux共享库的组织 动态链接器会在/lib、/usr/lib、 /etc/ld.so.conf配置文件指定的目录中查找共享库 共享库文件名 libname.</description></item><item><title>Effective c++</title><link>https://xiabing992.github.io/blog/effective-c++/effective-c++/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/effective-c++/effective-c++/</guid><description>Effective C++ 导言 除非有好的理由允许隐式转换，否则声明explicit 拷贝构造函数和拷贝赋值操作符：如果有新对象被定义，一定会有个构造函数被调用 class Widget { public: Widget(); Widget(const Widget&amp;amp;rhs); Widget&amp;amp; operator=(const Widget&amp;amp; rhs); }; Widget w1; //调用构造函数 Widget w2(w1); //调用拷贝构造函数 w1 = w2; //调用 = Widget w3 = w2; //调用拷贝构造函数 让自己习惯C++ 视C++为一个语言联邦 C++ = &amp;lsquo;c&amp;rsquo; + &amp;lsquo;Object-Oriented c++&amp;rsquo; + &amp;lsquo;Template c++&amp;rsquo; + &amp;lsquo;STL&amp;rsquo; 在 C 中，pass-by-value通常比pass-by-reference高效，而在C++中由于构造函数和析构函数的存在，pass-by-reference-to-const往往更好（和编译器层面有关，存在空指针，但没有空引用） 尽量以const, enum, inline 替换#define 获得编译错误时，#define定义的方式会带来困惑 对于单纯常量，最好以const对象或enums替换#define 对于形似函数的宏，最好使用inline函数替换#define 尽可能使用const bitwise constess: const成员函数不能更改non-static成员变量
class Rational { ... }; const Rational operator* (const Rational&amp;amp; lhs,const Rational&amp;amp; rhs) { .</description></item><item><title/><link>https://xiabing992.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/about/</guid><description>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec id erat enim. Ut cursus magna sed luctus auctor. Sed eu augue dignissim, lobortis ipsum eu, dictum nisi. Integer varius ex maximus quam lobortis accumsan. Morbi mollis vulputate metus, aliquam feugiat arcu porta a. Quisque id justo ultricies, lacinia elit quis, pulvinar odio. Fusce feugiat at velit vitae lobortis. Nulla fringilla metus et sem mattis posuere.
Nulla pellentesque quam sit amet est posuere, tincidunt auctor ligula bibendum.</description></item><item><title/><link>https://xiabing992.github.io/blog/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/readme/</guid><description>符号表 Symbol significance ✔ yes! - 不是很懂，就这样吧 (折磨) ✘ 还没读 状态表 Book Status C++ Primer ✔ Effective C++ ✔ 程序员的自我修养 - 深入理解Linux网络 ✔ Linux 内核设计与实现 ✔ TCP/IP网络编程 ✔ 想读的 Book Status 汇编语言 ✘ Linux高性能服务器编程 ✘ 感觉还得在看一遍 Book Status Unix 环境高级编程 ✔ Unix 网络编程 ✔</description></item><item><title/><link>https://xiabing992.github.io/blog/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiabing992.github.io/blog/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</guid><description>author date Xiabing 2023-07-07 程序员的自我修养 静态编译 空间与地址分配 多个目标文件合并，生成的可执行文件代码段和数据段怎么合并？
$gcc -c a.c b.c $ld a.o b.o -e main -o ab 按序合并
缺点：空间浪费，由于每个段都有地址对齐要求
相似段合并（常用）
两步链接:
空间与地址分配：扫描所有输入目标文件，获取各个段的长度等信息，并将输入目标文件的符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表； 符号解析与重定位：使用上述收集到的信息，读取文件中的段的数据、重定位信息，并且进行符号解析和重定位等。 虚拟地址在链接之后被分配 在Linux下，ELF可执行文件从默认地址0x08048000开始分配 重定位 a.o文件是怎么访问shared变量和swap变量的？
链接器通过符号表的地址对每个需要重定位的指令进行修正。
重定位表 重定位表：用来调整需要调整的指令，专门保存这些与重定位相关的信息；
指令修正方式 jmp指令、call指令、mov指令等
绝对寻址 相对寻址 等等 COMMON块 弱符号：在C语言中，函数和初始化的全局变量（包括显示初始化为0）是强符号，未初始化的全局变量是弱符号
对于它们，下列三条规则使用：
同名的强符号只能有一个，否则编译器报&amp;quot;重复定义&amp;quot;错误。
允许一个强符号和多个弱符号，但定义会选择强符号的。
当有多个弱符号相同时，链接器选择最先出现那个，也就是与链接顺序有关。
如果一个弱符号定义在多个目标文件中，而他们类型又不同，怎么办？ 两个或者两个以上强类型不一致；（链接器报错） 有一个强符号，其他都是弱符号，出现类型不一致； 两个或者两个以上弱符号类型不一致； COMMON块机制：沿用Fortran机制，当不同目标文件需要的COMMON块空间大小不一致时，以最大的那块为准（这里只是占用空间以大的为准）
C++相关问题 c++的语言特性使得必须由编译器和链接器共同支持才能完成工作，如c++重复代码消除、全局构造和析构等。 虚函数、函数重载等背后的数据结构异常复杂，这些数据结构往往在不同的编译器和链接器之间不能通用，使得c++程序的二进制兼容性成为了一个很大的问题。 重复代码消除 如当一个模板被实例化成相同的类型后会产生重复的代码 解决办法：将每个模板的实例代码单独存放在一个段里，每个段只包含一个模板实例。如：add &amp;mdash;&amp;mdash; .temp.add .temp.add
全局构造与析构 c++全局对象的构造在main函数之前执行，析构函数在main之后执行 静态库链接 程序如何使用操作系统提供的API？
一种语言的开发环境会附带语言库，这些库就是对操作系统API的封装。（如printf在Linux下是“write”系统调用，Windows下是“WriteConsole“系统调用）
动态链接 为什么要使用动态链接？ 节约内存和磁盘空间 程序的开发与发布：使用静态链接，如果通过网络来更新程序，一旦程序改动一个小模块，整个程序都需要重新下载 **动态链接的基本思想：**把链接的过程推迟到运行时再进行
动态链接优点与缺点：
运行时动态的选择和加载各种程序模块，这个优点后来被用作制作程序的插件。 消除了不同平台依赖的差异性：如操作系统A和B对于printf的实现机制不同，如果是静态链接的，程序需要分别链接成能够再A和B上运行的两个版本；如果是动态链接，只需要操作系统提供一个动态链接库包含printf，则程序只需要一个版本，就可以动态的选择printf的实现版本。 DLL Hell：由于缺少一个有效的共享库版本的管理机制，使得用户出现新程序安装后，其他程序无法正常工作的现象。（这是因为某个新的模块与旧的模块之间接口不兼容，新安装的软件的模块覆盖了旧的模块） 动态链接会有性能损失 在静态链接中，整个程序只有一个可执行文件；但在动态链接下，一个程序被分成了可执行文件和所依赖的共享库</description></item></channel></rss>